diff --git a/AMBuildScript b/AMBuildScript
index 80e519e..8fecb89 100644
--- a/AMBuildScript
+++ b/AMBuildScript
@@ -91,7 +91,7 @@ class DHooksConfig(object):
         '-pipe',
         '-fno-strict-aliasing',
         '-Wall',
-        '-Werror',
+        #'-Werror',
         '-Wno-unused',
         '-Wno-switch',
         '-Wno-format',
@@ -103,7 +103,7 @@ class DHooksConfig(object):
 		'-Wno-invalid-offsetof',
       ]
       cxx.cxxflags += [
-          '-std=c++11',
+          '-std=c++14',
       ]
 
       have_gcc = cxx.vendor == 'gcc'
diff --git a/DynamicHooks/convention.h b/DynamicHooks/convention.h
index 1c65bc3..4bbf580 100644
--- a/DynamicHooks/convention.h
+++ b/DynamicHooks/convention.h
@@ -37,7 +37,8 @@
 #include "registers.h"
 #include <string.h>
 #include <am-vector.h>
-#include <am-autoptr.h>
+#include <memory>
+#include <cstdio>
 
 // ============================================================================
 // >> DataType_t
@@ -151,11 +152,11 @@ public:
 	@param <returnType>:
 	The return type of the function.
 	*/
-	ICallingConvention(ke::Vector<DataTypeSized_t> &vecArgTypes, DataTypeSized_t returnType, int iAlignment=4)
+	ICallingConvention(std::vector<DataTypeSized_t> &vecArgTypes, DataTypeSized_t returnType, int iAlignment=4)
 	{
-		m_vecArgTypes = ke::Move(vecArgTypes);
+		m_vecArgTypes = std::move(vecArgTypes);
 		
-		for (size_t i=0; i < m_vecArgTypes.length(); i++)
+		for (size_t i=0; i < m_vecArgTypes.size(); i++)
 		{
 			DataTypeSized_t &type = m_vecArgTypes[i];
 			if (!type.size)
@@ -175,7 +176,7 @@ public:
 	This should return a list of Register_t values. These registers will be
 	saved for later access.
 	*/
-	virtual ke::Vector<Register_t> GetRegisters() = 0;
+	virtual std::vector<Register_t> GetRegisters() = 0;
 
 	/*
 	Returns the number of bytes that should be added to the stack to clean up.
@@ -224,26 +225,26 @@ public:
 	{
 		uint8_t* pSavedReturnValue = new uint8_t[m_returnType.size];
 		memcpy(pSavedReturnValue, GetReturnPtr(pRegisters), m_returnType.size);
-		m_pSavedReturnBuffers.append(pSavedReturnValue);
+		m_pSavedReturnBuffers.emplace_back(pSavedReturnValue);
 	}
 
 	virtual void RestoreReturnValue(CRegisters* pRegisters)
 	{
-		uint8_t* pSavedReturnValue = m_pSavedReturnBuffers.back();
+		uint8_t* pSavedReturnValue = m_pSavedReturnBuffers.back().get();
 		memcpy(GetReturnPtr(pRegisters), pSavedReturnValue, m_returnType.size);
 		ReturnPtrChanged(pRegisters, pSavedReturnValue);
-		m_pSavedReturnBuffers.pop();
+		m_pSavedReturnBuffers.pop_back();
 	}
 
 	virtual void SavePostCallRegisters(CRegisters* pRegisters) {}
 	virtual void RestorePostCallRegisters(CRegisters* pRegisters)	{}
 
 public:
-	ke::Vector<DataTypeSized_t> m_vecArgTypes;
+	std::vector<DataTypeSized_t> m_vecArgTypes;
 	DataTypeSized_t m_returnType;
 	int m_iAlignment;
 	// Save the return in case we call the original function and want to override the return again.
-	ke::Vector<ke::AutoPtr<uint8_t>> m_pSavedReturnBuffers;
+	std::vector<std::unique_ptr<uint8_t>> m_pSavedReturnBuffers;
 };
 
 #endif // _CONVENTION_H
\ No newline at end of file
diff --git a/DynamicHooks/conventions/x86GccThiscall.cpp b/DynamicHooks/conventions/x86GccThiscall.cpp
index 38c559e..e15cc7d 100644
--- a/DynamicHooks/conventions/x86GccThiscall.cpp
+++ b/DynamicHooks/conventions/x86GccThiscall.cpp
@@ -38,7 +38,7 @@
 // >> CLASSES
 // ============================================================================
 
-x86GccThiscall::x86GccThiscall(ke::Vector<DataTypeSized_t> &vecArgTypes, DataTypeSized_t returnType, int iAlignment) :
+x86GccThiscall::x86GccThiscall(std::vector<DataTypeSized_t> &vecArgTypes, DataTypeSized_t returnType, int iAlignment) :
 	x86GccCdecl(vecArgTypes, returnType, iAlignment)
 {
 	// Always add the |this| pointer.
@@ -46,7 +46,7 @@ x86GccThiscall::x86GccThiscall(ke::Vector<DataTypeSized_t> &vecArgTypes, DataTyp
 	type.type = DATA_TYPE_POINTER;
 	type.size = GetDataTypeSize(type, iAlignment);
 	type.custom_register = None;
-	m_vecArgTypes.insert(0, type);
+	m_vecArgTypes.insert(m_vecArgTypes.begin(), type);
 }
 
 x86GccThiscall::~x86GccThiscall()
@@ -73,12 +73,12 @@ void x86GccThiscall::SavePostCallRegisters(CRegisters* pRegisters)
 {
 	uint8_t* pSavedThisPointer = new uint8_t[sizeof(size_t)];
 	memcpy(pSavedThisPointer, GetArgumentPtr(0, pRegisters), sizeof(size_t));
-	m_pSavedThisPointers.append(pSavedThisPointer);
+	m_pSavedThisPointers.emplace_back(pSavedThisPointer);
 }
 
 void x86GccThiscall::RestorePostCallRegisters(CRegisters* pRegisters)
 {
-	uint8_t* pSavedThisPointer = m_pSavedThisPointers.back();
+	uint8_t* pSavedThisPointer = m_pSavedThisPointers.back().get();
 	memcpy(GetArgumentPtr(0, pRegisters), pSavedThisPointer, sizeof(size_t));
-	m_pSavedThisPointers.pop();
+	m_pSavedThisPointers.pop_back();
 }
diff --git a/DynamicHooks/conventions/x86GccThiscall.h b/DynamicHooks/conventions/x86GccThiscall.h
index 7e0d0a7..5b53b54 100644
--- a/DynamicHooks/conventions/x86GccThiscall.h
+++ b/DynamicHooks/conventions/x86GccThiscall.h
@@ -36,7 +36,6 @@
 // ============================================================================
 #include "x86GccCdecl.h"
 #include <am-vector.h>
-#include <am-autoptr.h>
 
 
 // ============================================================================
@@ -46,7 +45,7 @@
 class x86GccThiscall: public x86GccCdecl
 {
 public:
-	x86GccThiscall(ke::Vector<DataTypeSized_t> &vecArgTypes, DataTypeSized_t returnType, int iAlignment = 4);
+	x86GccThiscall(std::vector<DataTypeSized_t> &vecArgTypes, DataTypeSized_t returnType, int iAlignment = 4);
 	virtual ~x86GccThiscall();
 
 	virtual int GetArgStackSize();
@@ -56,7 +55,7 @@ public:
 	virtual void RestorePostCallRegisters(CRegisters* pRegisters);
 
 private:
-	ke::Vector<ke::AutoPtr<uint8_t>> m_pSavedThisPointers;
+	std::vector<std::unique_ptr<uint8_t>> m_pSavedThisPointers;
 };
 
 #endif // _X86_GCC_THISCALL_H
\ No newline at end of file
diff --git a/DynamicHooks/conventions/x86MsCdecl.cpp b/DynamicHooks/conventions/x86MsCdecl.cpp
index 71d59ba..0ff3486 100644
--- a/DynamicHooks/conventions/x86MsCdecl.cpp
+++ b/DynamicHooks/conventions/x86MsCdecl.cpp
@@ -38,7 +38,7 @@
 // ============================================================================
 // >> x86MsCdecl
 // ============================================================================
-x86MsCdecl::x86MsCdecl(ke::Vector<DataTypeSized_t> &vecArgTypes, DataTypeSized_t returnType, int iAlignment) :
+x86MsCdecl::x86MsCdecl(std::vector<DataTypeSized_t> &vecArgTypes, DataTypeSized_t returnType, int iAlignment) :
 	ICallingConvention(vecArgTypes, returnType, iAlignment)
 {
 	if (m_returnType.size > 4)
@@ -59,33 +59,33 @@ x86MsCdecl::~x86MsCdecl()
 	}
 }
 
-ke::Vector<Register_t> x86MsCdecl::GetRegisters()
+std::vector<Register_t> x86MsCdecl::GetRegisters()
 {
-	ke::Vector<Register_t> registers;
+	std::vector<Register_t> registers;
 
-	registers.append(ESP);
+	registers.emplace_back(ESP);
 
 	if (m_returnType.type == DATA_TYPE_FLOAT || m_returnType.type == DATA_TYPE_DOUBLE)
 	{
-		registers.append(ST0);
+		registers.emplace_back(ST0);
 	}
 	else
 	{
-		registers.append(EAX);
+		registers.emplace_back(EAX);
 		if (m_pReturnBuffer)
 		{
-			registers.append(EDX);
+			registers.emplace_back(EDX);
 		}
 	}
 
 	// Save all the custom calling convention registers as well.
-	for (unsigned int i = 0; i < m_vecArgTypes.length(); i++)
+	for (unsigned int i = 0; i < m_vecArgTypes.size(); i++)
 	{
 		if (m_vecArgTypes[i].custom_register == None)
 			continue;
 
 		// TODO: Make sure the list is unique? Set?
-		registers.append(m_vecArgTypes[i].custom_register);
+		registers.emplace_back(m_vecArgTypes[i].custom_register);
 	}
 
 	return registers;
@@ -100,7 +100,7 @@ int x86MsCdecl::GetArgStackSize()
 {
 	int iArgStackSize = 0;
 
-	for (unsigned int i = 0; i < m_vecArgTypes.length(); i++)
+	for (unsigned int i = 0; i < m_vecArgTypes.size(); i++)
 	{
 		if (m_vecArgTypes[i].custom_register == None)
 			iArgStackSize += m_vecArgTypes[i].size;
@@ -118,7 +118,7 @@ int x86MsCdecl::GetArgRegisterSize()
 {
 	int iArgRegisterSize = 0;
 
-	for (unsigned int i = 0; i < m_vecArgTypes.length(); i++)
+	for (unsigned int i = 0; i < m_vecArgTypes.size(); i++)
 	{
 		if (m_vecArgTypes[i].custom_register != None)
 			iArgRegisterSize += m_vecArgTypes[i].size;
@@ -129,7 +129,7 @@ int x86MsCdecl::GetArgRegisterSize()
 
 void* x86MsCdecl::GetArgumentPtr(unsigned int iIndex, CRegisters* pRegisters)
 {
-	if (iIndex >= m_vecArgTypes.length())
+	if (iIndex >= m_vecArgTypes.size())
 		return NULL;
 
 	// Check if this argument was passed in a register.
diff --git a/DynamicHooks/conventions/x86MsCdecl.h b/DynamicHooks/conventions/x86MsCdecl.h
index d4fa497..27a1202 100644
--- a/DynamicHooks/conventions/x86MsCdecl.h
+++ b/DynamicHooks/conventions/x86MsCdecl.h
@@ -63,10 +63,10 @@ Return values:
 class x86MsCdecl: public ICallingConvention
 {	
 public:
-	x86MsCdecl(ke::Vector<DataTypeSized_t> &vecArgTypes, DataTypeSized_t returnType, int iAlignment=4);
+	x86MsCdecl(std::vector<DataTypeSized_t> &vecArgTypes, DataTypeSized_t returnType, int iAlignment=4);
 	virtual ~x86MsCdecl();
 
-	virtual ke::Vector<Register_t> GetRegisters();
+	virtual std::vector<Register_t> GetRegisters();
 	virtual int GetPopSize();
 	virtual int GetArgStackSize();
 	virtual void** GetStackArgumentPtr(CRegisters* pRegisters);
diff --git a/DynamicHooks/conventions/x86MsFastcall.cpp b/DynamicHooks/conventions/x86MsFastcall.cpp
index 0b9d8c0..31c3f3a 100644
--- a/DynamicHooks/conventions/x86MsFastcall.cpp
+++ b/DynamicHooks/conventions/x86MsFastcall.cpp
@@ -37,11 +37,11 @@
 // ============================================================================
 // >> x86MsFastcall
 // ============================================================================
-x86MsFastcall::x86MsFastcall(ke::Vector<DataTypeSized_t> &vecArgTypes, DataTypeSized_t returnType, int iAlignment) :
+x86MsFastcall::x86MsFastcall(std::vector<DataTypeSized_t> &vecArgTypes, DataTypeSized_t returnType, int iAlignment) :
 	x86MsStdcall(vecArgTypes, returnType, iAlignment)
 {
 	// First argument is passed in ecx.
-	if (m_vecArgTypes.length() > 0) {
+	if (m_vecArgTypes.size() > 0) {
 		DataTypeSized_t &type = m_vecArgTypes[0];
 		// Don't force the register on the user.
 		// Why choose Fastcall if you set your own argument registers though..
@@ -50,7 +50,7 @@ x86MsFastcall::x86MsFastcall(ke::Vector<DataTypeSized_t> &vecArgTypes, DataTypeS
 	}
 
 	// Second argument is passed in edx.
-	if (m_vecArgTypes.length() > 1) {
+	if (m_vecArgTypes.size() > 1) {
 		DataTypeSized_t &type = m_vecArgTypes[1];
 		if (type.custom_register == None)
 			type.custom_register = EDX;
diff --git a/DynamicHooks/conventions/x86MsFastcall.h b/DynamicHooks/conventions/x86MsFastcall.h
index 83fdf94..3ba5547 100644
--- a/DynamicHooks/conventions/x86MsFastcall.h
+++ b/DynamicHooks/conventions/x86MsFastcall.h
@@ -63,7 +63,7 @@ Return values:
 class x86MsFastcall: public x86MsStdcall
 {	
 public:
-	x86MsFastcall(ke::Vector<DataTypeSized_t> &vecArgTypes, DataTypeSized_t returnType, int iAlignment=4);
+	x86MsFastcall(std::vector<DataTypeSized_t> &vecArgTypes, DataTypeSized_t returnType, int iAlignment=4);
 };
 
 #endif // _X86_MS_FASTCALL_H
\ No newline at end of file
diff --git a/DynamicHooks/conventions/x86MsStdcall.cpp b/DynamicHooks/conventions/x86MsStdcall.cpp
index 62651f7..ee552d8 100644
--- a/DynamicHooks/conventions/x86MsStdcall.cpp
+++ b/DynamicHooks/conventions/x86MsStdcall.cpp
@@ -38,7 +38,7 @@
 // ============================================================================
 // >> x86MsStdcall
 // ============================================================================
-x86MsStdcall::x86MsStdcall(ke::Vector<DataTypeSized_t> &vecArgTypes, DataTypeSized_t returnType, int iAlignment) :
+x86MsStdcall::x86MsStdcall(std::vector<DataTypeSized_t> &vecArgTypes, DataTypeSized_t returnType, int iAlignment) :
 	ICallingConvention(vecArgTypes, returnType, iAlignment)
 {
 	if (m_returnType.size > 4)
@@ -59,33 +59,33 @@ x86MsStdcall::~x86MsStdcall()
 	}
 }
 
-ke::Vector<Register_t> x86MsStdcall::GetRegisters()
+std::vector<Register_t> x86MsStdcall::GetRegisters()
 {
-	ke::Vector<Register_t> registers;
+	std::vector<Register_t> registers;
 
-	registers.append(ESP);
+	registers.emplace_back(ESP);
 
 	if (m_returnType.type == DATA_TYPE_FLOAT || m_returnType.type == DATA_TYPE_DOUBLE)
 	{
-		registers.append(ST0);
+		registers.emplace_back(ST0);
 	}
 	else
 	{
-		registers.append(EAX);
+		registers.emplace_back(EAX);
 		if (m_pReturnBuffer)
 		{
-			registers.append(EDX);
+			registers.emplace_back(EDX);
 		}
 	}
 
 	// Save all the custom calling convention registers as well.
-	for (unsigned int i = 0; i < m_vecArgTypes.length(); i++)
+	for (unsigned int i = 0; i < m_vecArgTypes.size(); i++)
 	{
 		if (m_vecArgTypes[i].custom_register == None)
 			continue;
 
 		// TODO: Make sure the list is unique? Set?
-		registers.append(m_vecArgTypes[i].custom_register);
+		registers.emplace_back(m_vecArgTypes[i].custom_register);
 	}
 
 	return registers;
@@ -95,7 +95,7 @@ int x86MsStdcall::GetPopSize()
 {
 	int iPopSize = 0;
 
-	for(unsigned int i=0; i < m_vecArgTypes.length(); i++)
+	for(unsigned int i=0; i < m_vecArgTypes.size(); i++)
 	{
 		if (m_vecArgTypes[i].custom_register == None)
 			iPopSize += m_vecArgTypes[i].size;
@@ -108,7 +108,7 @@ int x86MsStdcall::GetArgStackSize()
 {
 	int iArgStackSize = 0;
 
-	for (unsigned int i = 0; i < m_vecArgTypes.length(); i++)
+	for (unsigned int i = 0; i < m_vecArgTypes.size(); i++)
 	{
 		if (m_vecArgTypes[i].custom_register == None)
 			iArgStackSize += m_vecArgTypes[i].size;
@@ -126,7 +126,7 @@ int x86MsStdcall::GetArgRegisterSize()
 {
 	int iArgRegisterSize = 0;
 
-	for (unsigned int i = 0; i < m_vecArgTypes.length(); i++)
+	for (unsigned int i = 0; i < m_vecArgTypes.size(); i++)
 	{
 		if (m_vecArgTypes[i].custom_register != None)
 			iArgRegisterSize += m_vecArgTypes[i].size;
@@ -137,7 +137,7 @@ int x86MsStdcall::GetArgRegisterSize()
 
 void* x86MsStdcall::GetArgumentPtr(unsigned int iIndex, CRegisters* pRegisters)
 {
-	if (iIndex >= m_vecArgTypes.length())
+	if (iIndex >= m_vecArgTypes.size())
 		return NULL;
 
 	// Check if this argument was passed in a register.
diff --git a/DynamicHooks/conventions/x86MsStdcall.h b/DynamicHooks/conventions/x86MsStdcall.h
index 5fb7ff2..6846e2c 100644
--- a/DynamicHooks/conventions/x86MsStdcall.h
+++ b/DynamicHooks/conventions/x86MsStdcall.h
@@ -63,10 +63,10 @@ Return values:
 class x86MsStdcall: public ICallingConvention
 {	
 public:
-	x86MsStdcall(ke::Vector<DataTypeSized_t> &vecArgTypes, DataTypeSized_t returnType, int iAlignment=4);
+	x86MsStdcall(std::vector<DataTypeSized_t> &vecArgTypes, DataTypeSized_t returnType, int iAlignment=4);
 	virtual ~x86MsStdcall();
 
-	virtual ke::Vector<Register_t> GetRegisters();
+	virtual std::vector<Register_t> GetRegisters();
 	virtual int GetPopSize();
 	virtual int GetArgStackSize();
 	virtual void** GetStackArgumentPtr(CRegisters* pRegisters);
diff --git a/DynamicHooks/conventions/x86MsThiscall.cpp b/DynamicHooks/conventions/x86MsThiscall.cpp
index 6b46a8a..8ccc8a6 100644
--- a/DynamicHooks/conventions/x86MsThiscall.cpp
+++ b/DynamicHooks/conventions/x86MsThiscall.cpp
@@ -38,7 +38,7 @@
 // ============================================================================
 // >> x86MsThiscall
 // ============================================================================
-x86MsThiscall::x86MsThiscall(ke::Vector<DataTypeSized_t> &vecArgTypes, DataTypeSized_t returnType, int iAlignment) :
+x86MsThiscall::x86MsThiscall(std::vector<DataTypeSized_t> &vecArgTypes, DataTypeSized_t returnType, int iAlignment) :
 	ICallingConvention(vecArgTypes, returnType, iAlignment)
 {
 	if (m_returnType.size > 4)
@@ -59,35 +59,35 @@ x86MsThiscall::~x86MsThiscall()
 	}
 }
 
-ke::Vector<Register_t> x86MsThiscall::GetRegisters()
+std::vector<Register_t> x86MsThiscall::GetRegisters()
 {
-	ke::Vector<Register_t> registers;
+	std::vector<Register_t> registers;
 	
-	registers.append(ESP);
+	registers.emplace_back(ESP);
 	// TODO: Allow custom this register.
-	registers.append(ECX);
+	registers.emplace_back(ECX);
 
 	if (m_returnType.type == DATA_TYPE_FLOAT || m_returnType.type == DATA_TYPE_DOUBLE)
 	{
-		registers.append(ST0);
+		registers.emplace_back(ST0);
 	}
 	else
 	{
-		registers.append(EAX);
+		registers.emplace_back(EAX);
 		if (m_pReturnBuffer)
 		{
-			registers.append(EDX);
+			registers.emplace_back(EDX);
 		}
 	}
 
 	// Save all the custom calling convention registers as well.
-	for (unsigned int i = 0; i < m_vecArgTypes.length(); i++)
+	for (unsigned int i = 0; i < m_vecArgTypes.size(); i++)
 	{
 		if (m_vecArgTypes[i].custom_register == None)
 			continue;
 
 		// TODO: Make sure the list is unique? Set?
-		registers.append(m_vecArgTypes[i].custom_register);
+		registers.emplace_back(m_vecArgTypes[i].custom_register);
 	}
 
 	return registers;
@@ -100,7 +100,7 @@ int x86MsThiscall::GetPopSize()
 	//int iPopSize = GetDataTypeSize(DATA_TYPE_POINTER, m_iAlignment);
 	int iPopSize = 0;
 
-	for(unsigned int i=0; i < m_vecArgTypes.length(); i++)
+	for(unsigned int i=0; i < m_vecArgTypes.size(); i++)
 	{
 		// Only pop arguments that are actually on the stack.
 		if (m_vecArgTypes[i].custom_register == None)
@@ -114,7 +114,7 @@ int x86MsThiscall::GetArgStackSize()
 {
 	int iArgStackSize = 0;
 
-	for (unsigned int i = 0; i < m_vecArgTypes.length(); i++)
+	for (unsigned int i = 0; i < m_vecArgTypes.size(); i++)
 	{
 		if (m_vecArgTypes[i].custom_register == None)
 			iArgStackSize += m_vecArgTypes[i].size;
@@ -132,7 +132,7 @@ int x86MsThiscall::GetArgRegisterSize()
 {
 	int iArgRegisterSize = 0;
 
-	for (unsigned int i = 0; i < m_vecArgTypes.length(); i++)
+	for (unsigned int i = 0; i < m_vecArgTypes.size(); i++)
 	{
 		if (m_vecArgTypes[i].custom_register != None)
 			iArgRegisterSize += m_vecArgTypes[i].size;
@@ -152,7 +152,7 @@ void* x86MsThiscall::GetArgumentPtr(unsigned int iIndex, CRegisters* pRegisters)
 	// The this pointer isn't explicitly defined as an argument.
 	iIndex--;
 	
-	if (iIndex >= m_vecArgTypes.length())
+	if (iIndex >= m_vecArgTypes.size())
 		return NULL;
 
 	// Check if this argument was passed in a register.
diff --git a/DynamicHooks/hook.cpp b/DynamicHooks/hook.cpp
index d7df3ba..8b8b004 100644
--- a/DynamicHooks/hook.cpp
+++ b/DynamicHooks/hook.cpp
@@ -115,7 +115,7 @@ void CHook::AddCallback(HookType_t eHookType, HookHandlerFn* pCallback)
 	if (!i.found()) {
 		HookHandlerSet set;
 		set.init();
-		m_hookHandler.add(i, eHookType, ke::Move(set));
+		m_hookHandler.add(i, eHookType, std::move(set));
 	}
 
 	i->value.add(pCallback);
@@ -158,7 +158,7 @@ ReturnAction_t CHook::HookHandler(HookType_t eHookType)
 	{
 		// Ignore hooks without a registered pre-hook handler.
 		ReturnAction_t lastPreReturnAction = m_LastPreReturnAction.back();
-		m_LastPreReturnAction.pop();
+		m_LastPreReturnAction.pop_back();
 		if (lastPreReturnAction == ReturnAction_Override)
 			m_pCallingConvention->RestoreReturnValue(m_pRegisters);
 		if (lastPreReturnAction < ReturnAction_Supercede)
@@ -180,7 +180,7 @@ ReturnAction_t CHook::HookHandler(HookType_t eHookType)
 
 	if (eHookType == HOOKTYPE_PRE)
 	{
-		m_LastPreReturnAction.append(returnAction);
+		m_LastPreReturnAction.emplace_back(returnAction);
 		if (returnAction == ReturnAction_Override)
 			m_pCallingConvention->SaveReturnValue(m_pRegisters);
 		if (returnAction < ReturnAction_Supercede)
@@ -201,7 +201,7 @@ void* __cdecl CHook::GetReturnAddress(void* pESP)
 	}
 
 	void *pRetAddr = r->value.back();
-	r->value.pop();
+	r->value.pop_back();
 
 	// Clear the stack address from the cache now that we ran the last post hook.
 	if (r->value.empty())
@@ -214,9 +214,9 @@ void __cdecl CHook::SetReturnAddress(void* pRetAddr, void* pESP)
 {
 	ReturnAddressMap::Insert i = m_RetAddr.findForAdd(pESP);
 	if (!i.found())
-		m_RetAddr.add(i, pESP, ke::Move(ke::Vector<void *>()));
+		m_RetAddr.add(i, pESP, std::move(std::vector<void *>()));
 
-	i->value.append(pRetAddr);
+	i->value.emplace_back(pRetAddr);
 }
 
 void* CHook::CreateBridge()
@@ -356,8 +356,8 @@ void CHook::Write_CallHandler(sp::MacroAssembler& masm, HookType_t type)
 
 void CHook::Write_SaveRegisters(sp::MacroAssembler& masm, HookType_t type)
 {
-	ke::Vector<Register_t> vecRegistersToSave = m_pCallingConvention->GetRegisters();
-	for(size_t i = 0; i < vecRegistersToSave.length(); i++)
+	std::vector<Register_t> vecRegistersToSave = m_pCallingConvention->GetRegisters();
+	for(size_t i = 0; i < vecRegistersToSave.size(); i++)
 	{
 		switch(vecRegistersToSave[i])
 		{
@@ -423,8 +423,8 @@ void CHook::Write_SaveRegisters(sp::MacroAssembler& masm, HookType_t type)
 
 void CHook::Write_RestoreRegisters(sp::MacroAssembler& masm, HookType_t type)
 {
-	ke::Vector<Register_t> vecRegistersToSave = m_pCallingConvention->GetRegisters();
-	for (size_t i = 0; i < vecRegistersToSave.length(); i++)
+	std::vector<Register_t> vecRegistersToSave = m_pCallingConvention->GetRegisters();
+	for (size_t i = 0; i < vecRegistersToSave.size(); i++)
 	{
 		switch (vecRegistersToSave[i])
 		{
diff --git a/DynamicHooks/hook.h b/DynamicHooks/hook.h
index 2f26e68..8797dd9 100644
--- a/DynamicHooks/hook.h
+++ b/DynamicHooks/hook.h
@@ -82,7 +82,7 @@ struct IntegerPolicy
 
 typedef ke::HashSet<HookHandlerFn*, ke::PointerPolicy<HookHandlerFn>> HookHandlerSet;
 typedef ke::HashMap<HookType_t, HookHandlerSet, IntegerPolicy> HookTypeMap;
-typedef ke::HashMap<void*, ke::Vector<void*>, ke::PointerPolicy<void>> ReturnAddressMap;
+typedef ke::HashMap<void*, std::vector<void*>, ke::PointerPolicy<void>> ReturnAddressMap;
 
 namespace sp
 {
@@ -208,7 +208,7 @@ public:
 	ReturnAddressMap m_RetAddr;
 
 	// Save the last return action of the pre HookHandler for use in the post handler.
-	ke::Vector<ReturnAction_t> m_LastPreReturnAction;
+	std::vector<ReturnAction_t> m_LastPreReturnAction;
 };
 
 #endif // _HOOK_H
\ No newline at end of file
diff --git a/DynamicHooks/manager.cpp b/DynamicHooks/manager.cpp
index 390e8bb..c3597d5 100644
--- a/DynamicHooks/manager.cpp
+++ b/DynamicHooks/manager.cpp
@@ -50,7 +50,7 @@ CHook* CHookManager::HookFunction(void* pFunc, ICallingConvention* pConvention)
 	}
 	
 	pHook = new CHook(pFunc, pConvention);
-	m_Hooks.append(pHook);
+	m_Hooks.emplace_back(pHook);
 	return pHook;
 }
 
@@ -59,12 +59,12 @@ void CHookManager::UnhookFunction(void* pFunc)
 	if (!pFunc)
 		return;
 
-	for (size_t i = 0; i < m_Hooks.length(); i++)
+	for (decltype(m_Hooks)::iterator i = m_Hooks.begin(); i != m_Hooks.end(); i++)
 	{
-		CHook* pHook = m_Hooks[i];
+		CHook* pHook = *i;
 		if (pHook->m_pFunc == pFunc)
 		{
-			m_Hooks.remove(i);
+			m_Hooks.erase(i);
 			delete pHook;
 			return;
 		}
@@ -76,7 +76,7 @@ CHook* CHookManager::FindHook(void* pFunc)
 	if (!pFunc)
 		return NULL;
 
-	for(size_t i = 0; i < m_Hooks.length(); i++)
+	for(size_t i = 0; i < m_Hooks.size(); i++)
 	{
 		CHook* pHook = m_Hooks[i];
 		if (pHook->m_pFunc == pFunc)
@@ -87,7 +87,7 @@ CHook* CHookManager::FindHook(void* pFunc)
 
 void CHookManager::UnhookAllFunctions()
 {
-	for(size_t i = 0; i < m_Hooks.length(); i++)
+	for(size_t i = 0; i < m_Hooks.size(); i++)
 		delete m_Hooks[i];
 
 	m_Hooks.clear();
diff --git a/DynamicHooks/manager.h b/DynamicHooks/manager.h
index 22b06a9..acfe676 100644
--- a/DynamicHooks/manager.h
+++ b/DynamicHooks/manager.h
@@ -68,7 +68,7 @@ public:
 	void UnhookAllFunctions();
 
 public:
-	ke::Vector<CHook *> m_Hooks;
+	std::vector<CHook *> m_Hooks;
 };
 
 
diff --git a/DynamicHooks/registers.cpp b/DynamicHooks/registers.cpp
index 77fe503..8aabb16 100644
--- a/DynamicHooks/registers.cpp
+++ b/DynamicHooks/registers.cpp
@@ -30,7 +30,7 @@
 
 #include "registers.h"
 
-CRegisters::CRegisters(ke::Vector<Register_t> registers)
+CRegisters::CRegisters(std::vector<Register_t> registers)
 {	
 	// ========================================================================
 	// >> 8-bit General purpose registers
@@ -361,9 +361,9 @@ CRegisters::~CRegisters()
 	DeleteRegister(m_st7);
 }
 
-CRegister* CRegisters::CreateRegister(ke::Vector<Register_t>& registers, Register_t reg, uint16_t iSize, uint16_t iAlignment)
+CRegister* CRegisters::CreateRegister(std::vector<Register_t>& registers, Register_t reg, uint16_t iSize, uint16_t iAlignment)
 {
-	for(size_t i = 0; i < registers.length(); i++)
+	for(size_t i = 0; i < registers.size(); i++)
 	{
 		if (registers[i] == reg)
 		{
diff --git a/DynamicHooks/registers.h b/DynamicHooks/registers.h
index acb0642..472ff20 100644
--- a/DynamicHooks/registers.h
+++ b/DynamicHooks/registers.h
@@ -36,7 +36,8 @@
 // >> INCLUDES
 // ============================================================================
 #include <am-vector.h>
-
+#include <cstdlib>
+#include <cstdint>
 
 // ============================================================================
 // >> Register_t
@@ -216,7 +217,7 @@ enum Register_t
 class CRegister
 {
 public:
-	CRegister(uint16_t iSize, uint16_t iAlignment = 0)
+	CRegister(std::uint16_t iSize, std::uint16_t iAlignment = 0)
 	{
 		m_iSize = iSize;
 		m_iAlignment = iAlignment;
@@ -268,8 +269,8 @@ public:
 	}
 
 public:
-	uint16_t m_iSize;
-	uint16_t m_iAlignment;
+	std::uint16_t m_iSize;
+	std::uint16_t m_iAlignment;
 	void* m_pAddress;
 };
 
@@ -280,13 +281,13 @@ public:
 class CRegisters
 {
 public:
-	CRegisters(ke::Vector<Register_t> registers);
+	CRegisters(std::vector<Register_t> registers);
 	~CRegisters();
 
 	CRegister* GetRegister(Register_t reg);
 
 private:
-	CRegister* CreateRegister(ke::Vector<Register_t>& registers, Register_t reg, uint16_t iSize, uint16_t iAlignment = 0);
+	CRegister* CreateRegister(std::vector<Register_t>& registers, Register_t reg, std::uint16_t iSize, std::uint16_t iAlignment = 0);
 	void DeleteRegister(CRegister* pRegister);
 
 public:
diff --git a/dynhooks_sourcepawn.cpp b/dynhooks_sourcepawn.cpp
index 55abc2b..e46f68d 100644
--- a/dynhooks_sourcepawn.cpp
+++ b/dynhooks_sourcepawn.cpp
@@ -1,6 +1,6 @@
 #include "dynhooks_sourcepawn.h"
 #include "util.h"
-#include <am-autoptr.h>
+#include <memory>
 
 #ifdef KE_WINDOWS
 #include "conventions/x86MsCdecl.h"
@@ -68,7 +68,10 @@ bool AddDetourPluginHook(HookType_t hookType, CHook *pDetour, HookSetup *setup,
 
 	// Add the plugin callback to the detour list.
 	CDynamicHooksSourcePawn *pWrapper = new CDynamicHooksSourcePawn(setup, pDetour, pCallback, hookType == HOOKTYPE_POST);
-	if (!wrappers->append(pWrapper))
+
+	wrappers->emplace_back(pWrapper);
+
+	/*if (!wrappers->append(pWrapper))
 	{
 		if (wrappers->empty())
 		{
@@ -78,7 +81,7 @@ bool AddDetourPluginHook(HookType_t hookType, CHook *pDetour, HookSetup *setup,
 		}
 		delete pWrapper;
 		return false;
-	}
+	}*/
 
 	return true;
 }
@@ -98,14 +101,14 @@ bool RemoveDetourPluginHook(HookType_t hookType, CHook *pDetour, IPluginFunction
 	// Remove the plugin's callback
 	bool bRemoved = false;
 	PluginCallbackList *wrappers = res->value;
-	for (int i = wrappers->length()-1; i >= 0 ; i--)
+	for (PluginCallbackList::reverse_iterator i = wrappers->rbegin(); i != wrappers->rend(); i++)
 	{
-		CDynamicHooksSourcePawn *pWrapper = wrappers->at(i);
+		CDynamicHooksSourcePawn *pWrapper = *i;
 		if (pWrapper->plugin_callback == pCallback)
 		{
 			bRemoved = true;
 			delete pWrapper;
-			wrappers->remove(i);
+			wrappers->erase( std::next(i).base() );
 		}
 	}
 
@@ -131,14 +134,14 @@ void RemoveAllCallbacksForContext(HookType_t hookType, DetourMap *map, IPluginCo
 		wrappers = it->value;
 		// See if there are callbacks of this plugin context registered
 		// and remove them.
-		for (int i = wrappers->length() - 1; i >= 0; i--)
+		for (PluginCallbackList::reverse_iterator i = wrappers->rbegin(); i != wrappers->rend(); i++)
 		{
-			pWrapper = wrappers->at(i);
+			pWrapper = *i;
 			if (pWrapper->plugin_callback->GetParentRuntime()->GetDefaultContext() != pContext)
 				continue;
 
 			delete pWrapper;
-			wrappers->remove(i);
+			wrappers->erase( std::next(i).base() );
 		}
 
 		// No plugin interested in this hook anymore. unhook.
@@ -167,7 +170,7 @@ void CleanupDetours(HookType_t hookType, DetourMap *map)
 	{
 		wrappers = it->value;
 		// Remove all callbacks
-		for (int i = wrappers->length() - 1; i >= 0; i--)
+		for (int i = wrappers->size() - 1; i >= 0; i--)
 		{
 			pWrapper = wrappers->at(i);
 			delete pWrapper;
@@ -189,7 +192,7 @@ void CleanupDetours()
 ICallingConvention *ConstructCallingConvention(HookSetup *setup)
 {
 	// Convert function parameter types into DynamicHooks structures.
-	ke::Vector<DataTypeSized_t> vecArgTypes;
+	std::vector<DataTypeSized_t> vecArgTypes;
 	for (size_t i = 0; i < setup->params.size(); i++)
 	{
 		ParamInfo &info = setup->params[i];
@@ -197,7 +200,7 @@ ICallingConvention *ConstructCallingConvention(HookSetup *setup)
 		type.type = DynamicHooks_ConvertParamTypeFrom(info.type);
 		type.size = info.size;
 		type.custom_register = info.custom_register;
-		vecArgTypes.append(type);
+		vecArgTypes.emplace_back(type);
 	}
 
 	DataTypeSized_t returnType;
@@ -236,8 +239,8 @@ bool UpdateRegisterArgumentSizes(CHook* pDetour, HookSetup *setup)
 	// Update the type info to the size of the register that's now holding that argument,
 	// so we can copy the whole value.
 	ICallingConvention* callingConvention = pDetour->m_pCallingConvention;
-	ke::Vector<DataTypeSized_t> &argTypes = callingConvention->m_vecArgTypes;
-	int numArgs = argTypes.length();
+	std::vector<DataTypeSized_t> &argTypes = callingConvention->m_vecArgTypes;
+	int numArgs = argTypes.size();
 
 	for (int i = 0; i < numArgs; i++)
 	{
@@ -261,7 +264,7 @@ bool UpdateRegisterArgumentSizes(CHook* pDetour, HookSetup *setup)
 ReturnAction_t HandleDetour(HookType_t hookType, CHook* pDetour)
 {
 	// Can't call into SourcePawn offthread.
-	if (g_MainThreadId != ke::GetCurrentThreadId())
+	if (g_MainThreadId != std::this_thread::get_id())
 		return ReturnAction_Ignored;
 
 	DetourMap *map;
@@ -284,13 +287,13 @@ ReturnAction_t HandleDetour(HookType_t hookType, CHook* pDetour)
 	HookParamsStruct *paramStruct = NULL;
 	Handle_t pHndl = BAD_HANDLE;
 
-	int argNum = pDetour->m_pCallingConvention->m_vecArgTypes.length();
+	int argNum = pDetour->m_pCallingConvention->m_vecArgTypes.size();
 	// Keep a copy of the last return value if some plugin wants to override or supercede the function.
 	ReturnAction_t finalRet = ReturnAction_Ignored;
-	ke::AutoPtr<uint8_t> finalRetBuf(new uint8_t[pDetour->m_pCallingConvention->m_returnType.size]);
+	std::unique_ptr<uint8_t> finalRetBuf(new uint8_t[pDetour->m_pCallingConvention->m_returnType.size]);
 
 	// Call all the plugin functions..
-	for (size_t i = 0; i < wrappers->length(); i++)
+	for (size_t i = 0; i < wrappers->size(); i++)
 	{
 		CDynamicHooksSourcePawn *pWrapper = wrappers->at(i);
 		IPluginFunction *pCallback = pWrapper->plugin_callback;
@@ -423,7 +426,7 @@ ReturnAction_t HandleDetour(HookType_t hookType, CHook* pDetour)
 		{
 			// Copy the action and return value.
 			finalRet = tempRet;
-			memcpy(finalRetBuf, &tempRetBuf, pDetour->m_pCallingConvention->m_returnType.size);
+			memcpy(finalRetBuf.get(), &tempRetBuf, pDetour->m_pCallingConvention->m_returnType.size);
 		}
 
 		// Free the handles again.
@@ -442,7 +445,7 @@ ReturnAction_t HandleDetour(HookType_t hookType, CHook* pDetour)
 	if (finalRet >= ReturnAction_Override)
 	{
 		void* pPtr = pDetour->m_pCallingConvention->GetReturnPtr(pDetour->m_pRegisters);
-		memcpy(pPtr, finalRetBuf, pDetour->m_pCallingConvention->m_returnType.size);
+		memcpy(pPtr, finalRetBuf.get(), pDetour->m_pCallingConvention->m_returnType.size);
 		pDetour->m_pCallingConvention->ReturnPtrChanged(pDetour->m_pRegisters, pPtr);
 	}
 
@@ -558,8 +561,8 @@ HookParamsStruct *CDynamicHooksSourcePawn::GetParamStruct()
 	ICallingConvention* callingConvention = m_pDetour->m_pCallingConvention;
 	size_t stackSize = callingConvention->GetArgStackSize();
 	size_t paramsSize = stackSize + callingConvention->GetArgRegisterSize();
-	ke::Vector<DataTypeSized_t> &argTypes = callingConvention->m_vecArgTypes;
-	int numArgs = argTypes.length();
+	std::vector<DataTypeSized_t> &argTypes = callingConvention->m_vecArgTypes;
+	int numArgs = argTypes.size();
 
 	// Create space for original parameters and changes plugins might do.
 	params->orgParams = (void **)malloc(paramsSize);
@@ -608,8 +611,8 @@ void CDynamicHooksSourcePawn::UpdateParamsFromStruct(HookParamsStruct *params)
 
 	ICallingConvention* callingConvention = m_pDetour->m_pCallingConvention;
 	size_t stackSize = callingConvention->GetArgStackSize();
-	ke::Vector<DataTypeSized_t> &argTypes = callingConvention->m_vecArgTypes;
-	int numArgs = argTypes.length();
+	std::vector<DataTypeSized_t> &argTypes = callingConvention->m_vecArgTypes;
+	int numArgs = argTypes.size();
 
 	int firstArg = 0;
 	// TODO: Support custom register for this ptr.
diff --git a/dynhooks_sourcepawn.h b/dynhooks_sourcepawn.h
index 4f0e656..3e9f07b 100644
--- a/dynhooks_sourcepawn.h
+++ b/dynhooks_sourcepawn.h
@@ -8,7 +8,7 @@
 
 class CDynamicHooksSourcePawn;
 typedef ke::HashMap<IPluginFunction *, CDynamicHooksSourcePawn *, ke::PointerPolicy<IPluginFunction>> CallbackMap;
-typedef ke::Vector<CDynamicHooksSourcePawn *> PluginCallbackList;
+typedef std::vector<CDynamicHooksSourcePawn *> PluginCallbackList;
 typedef ke::HashMap<CHook *, PluginCallbackList *, ke::PointerPolicy<CHook>> DetourMap;
 
 //extern ke::Vector<CHook *> g_pDetours;
diff --git a/extension.cpp b/extension.cpp
index c7e3105..07d185a 100644
--- a/extension.cpp
+++ b/extension.cpp
@@ -15,7 +15,7 @@ HandleType_t g_HookSetupHandle = 0;
 HandleType_t g_HookParamsHandle = 0;
 HandleType_t g_HookReturnHandle = 0;
 
-ke::ThreadId g_MainThreadId;
+std::thread::id g_MainThreadId;
 
 bool DHooks::SDK_OnLoad(char *error, size_t maxlength, bool late)
 {
@@ -61,7 +61,7 @@ bool DHooks::SDK_OnLoad(char *error, size_t maxlength, bool late)
 
 	g_pEntityListener = new DHooksEntityListener();
 	g_pSignatures = new SignatureGameConfig();
-	g_MainThreadId = ke::GetCurrentThreadId();
+	g_MainThreadId = std::this_thread::get_id();
 
 	return true;
 }
diff --git a/extension.h b/extension.h
index f66276a..3e2c8ca 100644
--- a/extension.h
+++ b/extension.h
@@ -43,7 +43,7 @@
 #include <IBinTools.h>
 #include <ISDKTools.h>
 #include "sdk-hacks.h"
-#include <amtl/am-thread-utils.h>
+#include <thread>
 
 /**
  * @brief Sample implementation of the SDK Extension.
@@ -130,5 +130,5 @@ public:
 };
 extern SourceHook::IHookManagerAutoGen *g_pHookManager;
 extern sp_nativeinfo_t g_Natives[];
-extern ke::ThreadId g_MainThreadId;
+extern std::thread::id g_MainThreadId;
 #endif // _INCLUDE_SOURCEMOD_EXTENSION_PROPER_H_
diff --git a/listeners.cpp b/listeners.cpp
index 478bddf..3ba531b 100644
--- a/listeners.cpp
+++ b/listeners.cpp
@@ -3,42 +3,42 @@
 
 using namespace SourceHook;
 
-ke::Vector<EntityListener> g_EntityListeners;
-ke::Vector<DHooksManager *>g_pRemoveList;
+std::vector<EntityListener> g_EntityListeners;
+std::vector<DHooksManager *>g_pRemoveList;
 
 void FrameCleanupHooks(void *data)
 {
-	for (int i = g_pRemoveList.length() - 1; i >= 0; i--)
+	for(decltype(g_pRemoveList)::reverse_iterator i = g_pRemoveList.rbegin(); i != g_pRemoveList.rend(); i++)
 	{
-		DHooksManager *manager = g_pRemoveList.at(i);
+		DHooksManager *manager = *i;
 		delete manager;
-		g_pRemoveList.remove(i);
+		g_pRemoveList.erase( std::next(i).base() );
 	}
 }
 
 void DHooks::OnCoreMapEnd()
 {
-	for(int i = g_pHooks.length() -1; i >= 0; i--)
+	for(decltype(g_pHooks)::reverse_iterator i = g_pHooks.rbegin(); i != g_pHooks.rend(); i++)
 	{
-		DHooksManager *manager = g_pHooks.at(i);
+		DHooksManager *manager = *i;
 		if(manager->callback->hookType == HookType_GameRules)
 		{
 			delete manager;
-			g_pHooks.remove(i);
+			g_pHooks.erase( std::next(i).base() );
 		}
 	}
 }
 
 void DHooksEntityListener::CleanupListeners(IPluginContext *pContext)
 {
-	for(int i = g_EntityListeners.length() -1; i >= 0; i--)
+	for(decltype(g_EntityListeners)::reverse_iterator i = g_EntityListeners.rbegin(); i != g_EntityListeners.rend(); i++)
 	{
-		if(pContext == NULL || pContext == g_EntityListeners.at(i).callback->GetParentRuntime()->GetDefaultContext())
+		if(pContext == NULL || pContext == (*i).callback->GetParentRuntime()->GetDefaultContext())
 		{
-			g_EntityListeners.remove(i);
+			g_EntityListeners.erase( std::next(i).base() );
 		}
 	}
-	for (int i = g_pRemoveList.length() -1; i >= 0; i--)
+	for (int i = g_pRemoveList.size() -1; i >= 0; i--)
 	{
 		DHooksManager *manager = g_pRemoveList.at(i);
 		if (pContext == NULL || pContext == manager->callback->plugin_callback->GetParentRuntime()->GetDefaultContext())
@@ -52,7 +52,7 @@ void DHooksEntityListener::OnEntityCreated(CBaseEntity *pEntity, const char *cla
 {
 	int entity = gamehelpers->EntityToBCompatRef(pEntity);
 
-	for(int i = g_EntityListeners.length() -1; i >= 0; i--)
+	for(int i = g_EntityListeners.size() -1; i >= 0; i--)
 	{
 		EntityListener listerner = g_EntityListeners.at(i);
 		if(listerner.type == ListenType_Created)
@@ -69,7 +69,7 @@ void DHooksEntityListener::OnEntityDestroyed(CBaseEntity *pEntity)
 {
 	int entity = gamehelpers->EntityToBCompatRef(pEntity);
 
-	for(int i = g_EntityListeners.length() -1; i >= 0; i--)
+	for(int i = g_EntityListeners.size() -1; i >= 0; i--)
 	{
 		EntityListener listerner = g_EntityListeners.at(i);
 		if(listerner.type == ListenType_Deleted)
@@ -80,24 +80,24 @@ void DHooksEntityListener::OnEntityDestroyed(CBaseEntity *pEntity)
 		}
 	}
 
-	for(int i = g_pHooks.length() -1; i >= 0; i--)
+	for(decltype(g_pHooks)::reverse_iterator i = g_pHooks.rbegin(); i != g_pHooks.rend(); i++)
 	{
-		DHooksManager *manager = g_pHooks.at(i);
+		DHooksManager *manager = *i;
 		if(manager->callback->hookType == HookType_Entity && manager->callback->entity == entity)
 		{
-			if(g_pRemoveList.length() == 0)
+			if(g_pRemoveList.size() == 0)
 			{
 				smutils->AddFrameAction(&FrameCleanupHooks, NULL);
 			}
 
-			g_pRemoveList.append(manager);
-			g_pHooks.remove(i);
+			g_pRemoveList.emplace_back(manager);
+			g_pHooks.erase( std::next(i).base() );
 		}
 	}
 }
 bool DHooksEntityListener::AddPluginEntityListener(ListenType type, IPluginFunction *callback)
 {
-	for(int i = g_EntityListeners.length() -1; i >= 0; i--)
+	for(int i = g_EntityListeners.size() -1; i >= 0; i--)
 	{
 		EntityListener listerner = g_EntityListeners.at(i);
 		if(listerner.callback == callback && listerner.type == type)
@@ -108,17 +108,17 @@ bool DHooksEntityListener::AddPluginEntityListener(ListenType type, IPluginFunct
 	EntityListener listener;
 	listener.callback = callback;
 	listener.type = type;
-	g_EntityListeners.append(listener);
+	g_EntityListeners.emplace_back(listener);
 	return true;
 }
 bool DHooksEntityListener::RemovePluginEntityListener(ListenType type, IPluginFunction *callback)
 {
-	for(int i = g_EntityListeners.length() -1; i >= 0; i--)
+	for(decltype(g_EntityListeners)::reverse_iterator i = g_EntityListeners.rbegin(); i != g_EntityListeners.rend(); i++)
 	{
-		EntityListener listerner = g_EntityListeners.at(i);
+		EntityListener listerner = *i;
 		if(listerner.callback == callback && listerner.type == type)
 		{
-			g_EntityListeners.remove(i);
+			g_EntityListeners.erase( std::next(i).base() );
 			return true;
 		}
 	}
diff --git a/listeners.h b/listeners.h
index 822ec9c..3909ff0 100644
--- a/listeners.h
+++ b/listeners.h
@@ -28,5 +28,5 @@ struct EntityListener
 	IPluginFunction *callback;
 };
 
-extern ke::Vector<DHooksManager *> g_pHooks;
+extern std::vector<DHooksManager *> g_pHooks;
 #endif
diff --git a/natives.cpp b/natives.cpp
index 373caa1..7dd84c7 100644
--- a/natives.cpp
+++ b/natives.cpp
@@ -101,7 +101,7 @@ cell_t Native_DHookCreateFromConf(IPluginContext *pContext, const cell_t *params
 	if (sig->offset.length() > 0)
 	{
 		int offset;
-		if (!conf->GetOffset(sig->offset.chars(), &offset))
+		if (!conf->GetOffset(sig->offset.c_str(), &offset))
 		{
 			return BAD_HANDLE;
 		}
@@ -114,14 +114,14 @@ cell_t Native_DHookCreateFromConf(IPluginContext *pContext, const cell_t *params
 		void *addr = nullptr;;
 		if (sig->signature.length() > 0)
 		{
-			if (!conf->GetMemSig(sig->signature.chars(), &addr) || !addr)
+			if (!conf->GetMemSig(sig->signature.c_str(), &addr) || !addr)
 			{
 				return BAD_HANDLE;
 			}
 		}
 		else
 		{
-			if (!conf->GetAddress(sig->address.chars(), &addr) || !addr)
+			if (!conf->GetAddress(sig->address.c_str(), &addr) || !addr)
 			{
 				return BAD_HANDLE;
 			}
@@ -363,9 +363,9 @@ cell_t Native_HookEntity(IPluginContext *pContext, const cell_t *params)
 	}
 	bool post = params[2] != 0;
 
-	for(int i = g_pHooks.length() -1; i >= 0; i--)
+	for(decltype(g_pHooks)::reverse_iterator i = g_pHooks.rbegin(); i != g_pHooks.rend(); i++)
 	{
-		DHooksManager *manager = g_pHooks.at(i);
+		DHooksManager *manager = *i;
 		if(manager->callback->hookType == HookType_Entity && manager->callback->entity == gamehelpers->ReferenceToBCompatRef(params[3]) && manager->callback->offset == setup->offset && manager->callback->post == post && manager->remove_callback == pContext->GetFunctionById(params[4]) && manager->callback->plugin_callback == setup->callback)
 		{
 			return manager->hookid;
@@ -393,7 +393,7 @@ cell_t Native_HookEntity(IPluginContext *pContext, const cell_t *params)
 		return 0;
 	}
 
-	g_pHooks.append(manager);
+	g_pHooks.emplace_back(manager);
 
 	return manager->hookid;
 }
@@ -419,9 +419,9 @@ cell_t Native_HookGamerules(IPluginContext *pContext, const cell_t *params)
 
 	bool post = params[2] != 0;
 
-	for(int i = g_pHooks.length() -1; i >= 0; i--)
+	for(decltype(g_pHooks)::reverse_iterator i = g_pHooks.rbegin(); i != g_pHooks.rend(); i++)
 	{
-		DHooksManager *manager = g_pHooks.at(i);
+		DHooksManager *manager = *i;
 		if(manager->callback->hookType == HookType_GameRules && manager->callback->offset == setup->offset && manager->callback->post == post && manager->remove_callback == pContext->GetFunctionById(params[3]) && manager->callback->plugin_callback == setup->callback)
 		{
 			return manager->hookid;
@@ -450,7 +450,7 @@ cell_t Native_HookGamerules(IPluginContext *pContext, const cell_t *params)
 		return 0;
 	}
 
-	g_pHooks.append(manager);
+	g_pHooks.emplace_back(manager);
 
 	return manager->hookid;
 }
@@ -477,9 +477,9 @@ cell_t Native_HookRaw(IPluginContext *pContext, const cell_t *params)
 	bool post = params[2] != 0;
 	void *iface = (void *)(params[3]);
 
-	for(int i = g_pHooks.length() -1; i >= 0; i--)
+	for(decltype(g_pHooks)::reverse_iterator i = g_pHooks.rbegin(); i != g_pHooks.rend(); i++)
 	{
-		DHooksManager *manager = g_pHooks.at(i);
+		DHooksManager *manager = *i;
 		if(manager->callback->hookType == HookType_Raw && manager->addr == (intptr_t)iface && manager->callback->offset == setup->offset && manager->callback->post == post && manager->remove_callback == pContext->GetFunctionById(params[4]) && manager->callback->plugin_callback == setup->callback)
 		{
 			return manager->hookid;
@@ -506,20 +506,20 @@ cell_t Native_HookRaw(IPluginContext *pContext, const cell_t *params)
 		return 0;
 	}
 
-	g_pHooks.append(manager);
+	g_pHooks.emplace_back(manager);
 
 	return manager->hookid;
 }
 // native bool:DHookRemoveHookID(hookid);
 cell_t Native_RemoveHookID(IPluginContext *pContext, const cell_t *params)
 {
-	for(int i = g_pHooks.length() -1; i >= 0; i--)
+	for(decltype(g_pHooks)::reverse_iterator i = g_pHooks.rbegin(); i != g_pHooks.rend(); i++)
 	{
-		DHooksManager *manager = g_pHooks.at(i);
+		DHooksManager *manager = *i;
 		if(manager->hookid == params[1] && manager->callback->plugin_callback->GetParentRuntime()->GetDefaultContext() == pContext)
 		{
 			delete manager;
-			g_pHooks.remove(i);
+			g_pHooks.erase( std::next(i).base() );
 			return 1;
 		}
 	}
diff --git a/natives.h b/natives.h
index 4299488..8415ae1 100644
--- a/natives.h
+++ b/natives.h
@@ -10,5 +10,5 @@ extern ISDKTools *g_pSDKTools;
 extern HandleType_t g_HookSetupHandle;
 extern HandleType_t g_HookParamsHandle;
 extern HandleType_t g_HookReturnHandle;
-extern ke::Vector<DHooksManager *> g_pHooks;
+extern std::vector<DHooksManager *> g_pHooks;
 #endif
diff --git a/signatures.cpp b/signatures.cpp
index f1c6b92..e7f0138 100644
--- a/signatures.cpp
+++ b/signatures.cpp
@@ -17,7 +17,7 @@ unsigned int g_IgnoreLevel;
 ParseState g_PlatformOnlyState;
 
 SignatureWrapper *g_CurrentSignature;
-ke::AString g_CurrentFunctionName;
+std::string g_CurrentFunctionName;
 ArgumentInfo g_CurrentArgumentInfo;
 
 SignatureWrapper *SignatureGameConfig::GetFunctionSignature(const char *function)
@@ -53,7 +53,7 @@ SMCResult SignatureGameConfig::ReadSMC_NewSection(const SMCStates *states, const
 		// We're already in a section for a different OS that we're ignoring. Can't have a section for our OS in here.
 		if (g_IgnoreLevel > 0)
 		{
-			smutils->LogError(myself, "Unreachable platform specific section in \"%s\" Function: line: %i col: %i", g_CurrentFunctionName.chars(), states->line, states->col);
+			smutils->LogError(myself, "Unreachable platform specific section in \"%s\" Function: line: %i col: %i", g_CurrentFunctionName.c_str(), states->line, states->col);
 			return SMCResult_HaltFail;
 		}
 
@@ -78,7 +78,7 @@ SMCResult SignatureGameConfig::ReadSMC_NewSection(const SMCStates *states, const
 	{
 		if (g_PlatformOnlyState != PState_None)
 		{
-			smutils->LogError(myself, "Unreachable platform specific section in \"%s\" Function: line: %i col: %i", g_CurrentFunctionName.chars(), states->line, states->col);
+			smutils->LogError(myself, "Unreachable platform specific section in \"%s\" Function: line: %i col: %i", g_CurrentFunctionName.c_str(), states->line, states->col);
 			return SMCResult_HaltFail;
 		}
 
@@ -256,7 +256,7 @@ SMCResult SignatureGameConfig::ReadSMC_KeyValue(const SMCStates *states, const c
 			g_CurrentArgumentInfo.info.type = GetHookParamTypeFromString(value);
 			if (g_CurrentArgumentInfo.info.type == HookParamType_Unknown)
 			{
-				smutils->LogError(myself, "Invalid argument type \"%s\" for argument \"%s\": line: %i col: %i", value, g_CurrentArgumentInfo.name.chars(), states->line, states->col);
+				smutils->LogError(myself, "Invalid argument type \"%s\" for argument \"%s\": line: %i col: %i", value, g_CurrentArgumentInfo.name.c_str(), states->line, states->col);
 				return SMCResult_HaltFail;
 			}
 		}
@@ -266,7 +266,7 @@ SMCResult SignatureGameConfig::ReadSMC_KeyValue(const SMCStates *states, const c
 
 			if (g_CurrentArgumentInfo.info.size < 1)
 			{
-				smutils->LogError(myself, "Invalid argument size \"%s\" for argument \"%s\": line: %i col: %i", value, g_CurrentArgumentInfo.name.chars(), states->line, states->col);
+				smutils->LogError(myself, "Invalid argument size \"%s\" for argument \"%s\": line: %i col: %i", value, g_CurrentArgumentInfo.name.c_str(), states->line, states->col);
 				return SMCResult_HaltFail;
 			}
 		}
@@ -341,13 +341,13 @@ SMCResult SignatureGameConfig::ReadSMC_LeavingSection(const SMCStates *states)
 
 		if (!g_CurrentSignature->address.length() && !g_CurrentSignature->signature.length() && !g_CurrentSignature->offset.length())
 		{
-			smutils->LogError(myself, "Function \"%s\" doesn't have a \"signature\", \"offset\" nor \"address\" set: line: %i col: %i", g_CurrentFunctionName.chars(), states->line, states->col);
+			smutils->LogError(myself, "Function \"%s\" doesn't have a \"signature\", \"offset\" nor \"address\" set: line: %i col: %i", g_CurrentFunctionName.c_str(), states->line, states->col);
 			return SMCResult_HaltFail;
 		}
 
 		// Save this function signature in our cache.
-		signatures_.insert(g_CurrentFunctionName.chars(), g_CurrentSignature);
-		g_CurrentFunctionName = nullptr;
+		signatures_.insert(g_CurrentFunctionName.c_str(), g_CurrentSignature);
+		g_CurrentFunctionName.clear();
 		g_CurrentSignature = nullptr;
 		break;
 	case PState_Arguments:
@@ -358,7 +358,7 @@ SMCResult SignatureGameConfig::ReadSMC_LeavingSection(const SMCStates *states)
 
 		if (g_CurrentArgumentInfo.info.type == HookParamType_Unknown)
 		{
-			smutils->LogError(myself, "Missing argument type for argument \"%s\": line: %i col: %i", g_CurrentArgumentInfo.name.chars(), states->line, states->col);
+			smutils->LogError(myself, "Missing argument type for argument \"%s\": line: %i col: %i", g_CurrentArgumentInfo.name.c_str(), states->line, states->col);
 			return SMCResult_HaltFail;
 		}
 
@@ -367,7 +367,7 @@ SMCResult SignatureGameConfig::ReadSMC_LeavingSection(const SMCStates *states)
 		{
 			if (g_CurrentArgumentInfo.info.type == HookParamType_Object)
 			{
-				smutils->LogError(myself, "Object param \"%s\" being set with no size: line: %i col: %i", g_CurrentArgumentInfo.name.chars(), states->line, states->col);
+				smutils->LogError(myself, "Object param \"%s\" being set with no size: line: %i col: %i", g_CurrentArgumentInfo.name.c_str(), states->line, states->col);
 				return SMCResult_HaltFail;
 			}
 			else
@@ -392,9 +392,9 @@ SMCResult SignatureGameConfig::ReadSMC_LeavingSection(const SMCStates *states)
 		}
 		// This was a new argument. Add it to the end of the list.
 		if (!changed)
-			g_CurrentSignature->args.append(g_CurrentArgumentInfo);
+			g_CurrentSignature->args.emplace_back(g_CurrentArgumentInfo);
 
-		g_CurrentArgumentInfo.name = nullptr;
+		g_CurrentArgumentInfo.name.clear();
 		break;
 	}
 
@@ -407,8 +407,8 @@ void SignatureGameConfig::ReadSMC_ParseStart()
 	g_IgnoreLevel = 0;
 	g_PlatformOnlyState = PState_None;
 	g_CurrentSignature = nullptr;
-	g_CurrentFunctionName = nullptr;
-	g_CurrentArgumentInfo.name = nullptr;
+	g_CurrentFunctionName.clear();
+	g_CurrentArgumentInfo.name.clear();
 }
 
 ReturnType SignatureGameConfig::GetReturnTypeFromString(const char *str)
diff --git a/signatures.h b/signatures.h
index fa66b30..f3344d8 100644
--- a/signatures.h
+++ b/signatures.h
@@ -8,22 +8,22 @@
 #include <sm_stringhashmap.h>
 
 struct ArgumentInfo {
-	ArgumentInfo() : name(nullptr)
+	ArgumentInfo() : name()
 	{ }
 
-	ArgumentInfo(ke::AString name, ParamInfo info) : name(name), info(info)
+	ArgumentInfo(std::string name, ParamInfo info) : name(name), info(info)
 	{ }
 
-	ke::AString name;
+	std::string name;
 	ParamInfo info;
 };
 
 class SignatureWrapper {
 public:
-	ke::AString signature;
-	ke::AString address;
-	ke::AString offset;
-	ke::Vector<ArgumentInfo> args;
+	std::string signature;
+	std::string address;
+	std::string offset;
+	std::vector<ArgumentInfo> args;
 	CallingConvention callConv;
 	HookType hookType;
 	ReturnType retType;
diff --git a/vhook.cpp b/vhook.cpp
index c245a66..eb62dde 100644
--- a/vhook.cpp
+++ b/vhook.cpp
@@ -5,7 +5,7 @@
 
 SourceHook::IHookManagerAutoGen *g_pHookManager = NULL;
 
-ke::Vector<DHooksManager *> g_pHooks;
+std::vector<DHooksManager *> g_pHooks;
 
 using namespace SourceHook;
 using namespace sp;
@@ -167,14 +167,14 @@ DHooksManager::DHooksManager(HookSetup *setup, void *iface, IPluginFunction *rem
 
 void CleanupHooks(IPluginContext *pContext)
 {
-	for(int i = g_pHooks.length() -1; i >= 0; i--)
+	for(decltype(g_pHooks)::reverse_iterator i = g_pHooks.rbegin(); i != g_pHooks.rend(); i++)
 	{
-		DHooksManager *manager = g_pHooks.at(i);
+		DHooksManager *manager = *i;
 
 		if(pContext == NULL || pContext == manager->callback->plugin_callback->GetParentRuntime()->GetDefaultContext())
 		{
 			delete manager;
-			g_pHooks.remove(i);
+			g_pHooks.erase( std::next(i).base() );
 		}
 	}
 }
